# Windows API 读取屏幕图像（截图）

## 获取屏幕尺寸

```c
GetSystemMetrics(SM_CXSCREEN);  // 获取主显示器的逻辑宽度
GetSystemMetrics(SM_CYSCREEN);  // 获取主显示器的逻辑高度
```

或

```c
GetSystemMetrics(SM_CXVIRTUALSCREEN);   // 获取虚拟屏幕的逻辑宽度
GetSystemMetrics(SM_CXVIRTUALSCREEN);   // 获取虚拟屏幕的逻辑高度
```

如果开启了屏幕缩放，则可以调用以下代码忽略屏幕缩放：

```c
// 忽略缩放
SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2);
```

## 读取屏幕的图像

```c
// 获取屏幕设备上下文
HDC hScreenDC = GetDC(NULL);

// 创建兼容指定设备的内存设备上下文
HDC hMemDC = CreateCompatibleDC(hScreenDC);

// 创建兼容指定设备上下文的位图
HBITMAP hBitmap = CreateCompatibleBitmap(hScreenDC, width, height);

// 绑定内存设备上下文和位图
SelectObject(hMemDC, hBitmap);

// 将屏幕图像读取到内存设备上下文
BitBlt(hMemDC, 0, 0, width, height, hScreenDC, 0, 0, SRCCOPY | CAPTUREBLT);
```

## 从图像中读取像素

```c
// 创建位图的 Info Header
BITMAPINFOHEADER bi = {0};
bi.biSize = sizeof(BITMAPINFOHEADER);
bi.biWidth = width;
bi.biHeight = -height;      // 屏幕原点在左上角，位图原点在左下角
bi.biPlanes = 1;
bi.biBitCount = 24;         // 使用 24 位颜色，注意：颜色顺序是 BGR
bi.biCompression = BI_RGB;

// 读取像素
int lineBytes = ((bi.biWidth * bi.biBitCount + 31) / 32) * 4;   // 四字节对齐
int imageSize = lineBytes * height;
BYTE* pixels = malloc(imageSize);
GetDIBits(hMemDC, hBitmap, 0, height, pixels, (BITMAPINFO*)&bi, DIB_RGB_COLORS);
```

> 注意：BMP 的像素每行都按 4 字节对齐，并且颜色顺序是 BGR。

## 完整示例

```c
#include <stdio.h>
#include <Windows.h>

// 使用 MinGW 时需要添加 -lgdi32 选项
#pragma comment(lib, "gbi32.lib")

int main()
{
    // 获取虚拟屏幕尺寸
    int width  = GetSystemMetrics(SM_CXVIRTUALSCREEN);
    int height = GetSystemMetrics(SM_CYVIRTUALSCREEN);

    // 获取屏幕设备上下文
    HDC hScreenDC = GetDC(NULL);

    // 创建兼容指定设备的内存设备上下文
    HDC hMemDC = CreateCompatibleDC(hScreenDC);

    // 创建兼容指定设备上下文的位图
    HBITMAP hBitmap = CreateCompatibleBitmap(hScreenDC, width, height);

    // 绑定内存设备上下文和位图
    SelectObject(hMemDC, hBitmap);

    // 将屏幕图像读取到内存设备上下文
    BitBlt(hMemDC, 0, 0, width, height, hScreenDC, 0, 0, SRCCOPY | CAPTUREBLT);

    // 创建位图的 Info Header
    BITMAPINFOHEADER bi = {0};
    bi.biSize = sizeof(BITMAPINFOHEADER);
    bi.biWidth = width;
    bi.biHeight = -height;      // 屏幕原点在左上角，位图原点在左下角
    bi.biPlanes = 1;
    bi.biBitCount = 24;         // 使用 24 位颜色，注意：颜色顺序是 BGR
    bi.biCompression = BI_RGB;

    // 读取像素
    int lineBytes = ((bi.biWidth * bi.biBitCount + 31) / 32) * 4;   // 四字节对齐
    int imageSize = lineBytes * height;
    BYTE* pixels = malloc(imageSize);
    GetDIBits(hMemDC, hBitmap, 0, height, pixels, (BITMAPINFO*)&bi, DIB_RGB_COLORS);

    // 创建位图的 File Header
    BITMAPFILEHEADER bf = {0};
    bf.bfType = 0x4D42; // 'BM'
    bf.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);
    bf.bfSize = bf.bfOffBits + imageSize;

    // 写入文件
    FILE* fp = fopen("save.bmp", "wb");
    fwrite(&bf, sizeof(bf), 1, fp);
    fwrite(&bi, sizeof(bi), 1, fp);
    fwrite(pixels, imageSize, 1, fp);
    fclose(fp);

    // 释放资源
    free(pixels);
    DeleteObject(hBitmap);
    DeleteDC(hMemDC);
    ReleaseDC(NULL, hScreenDC);
    return 0;
}
```